2015.12.19 KJC

  It ain't tiddly but it will do. Deal.  Git's ability to diff between
  two revisions could use a LOT of work.  See "man gitrevisions". Copy
  and paste the following ghastlies, ONE at a time and study the output.
  (Installing most and "export PAGER=/usr/bin/most" in your .bashrc
  will help.)

  $ git log --reverse    # to see history in human-readable order
  $ git diff 642197bb6c4a573d7612901e2ea168c622676087..7f6e60404c1e24e08ae2815c62cbfe20f1ff92c9
  $ git diff 7f6e60404c1e24e08ae2815c62cbfe20f1ff92c9..9a824d97a81423b8e364f6bdd6e23ccb8c63e865

  ____________________________________________________________________________

2015.12.20 KJC

  In an attempt to be an enabler (but not a co-dependent), rather than
  a Frank Sinatra fix ("I did it Myyyyyyy Waaaaaayyyy") I've made what
  I consider to be minor changes to the code, that I hope will not be
  too arduous to adapt to. Now... to answer the immediate question at
  hand:  Looping through all methods of a class...

      $ ipython2

      # Disclaimer: This is a horrible and frightening way to do things

      from __future__ import print_function
      from nslcutil import *
      help(sdata)
      dir(sdata)
      attributes = dir(sdata)  # ALL attributes

      # Extract the methods, only (not all attributes)
      #
      # NOTE: "methods" and "attribute" below are just
      #       variable names and have NOTHING to do
      #       with the preceding lines
      #
      methods = [attribute for attribute in dir(sdata)
                 if not attribute.startswith("__") and
                 callable(getattr(sdata,attribute))]

      # This will print the method name, followed by
      # the output from calling said method.
      #
      for method in methods:
          print("\n{0}:".format(method))
          print(eval("sdata.{0}()".format(method)))

  Explanation: help() is your friend. Use it a LOT to get info
  about methods, objects, modules, data types, whatnot.

  dir() lists whatever's inside of the object fed to it. Sadly, these
  are strings. It list ALL attributes, including built-in stuff and
  things that are not methods.

  However, using a "list comprehension" we can filter out both built-
  in attributes, whose names all start with "__", and attributes which
  are not callable -- i.e. not methods.  But they are still,
  unfortunately strings.

  The last section above... I once again urge you to study modern
  string formatting techniques. "\n" you know. "{0}" is "put the first
  argument here". ("{1}" would be "put the second argument here".) So,
  print("\n{0}:".format(method)) is "Print a newline followed by the
  name of the method, followed by a colon".)

  And now, the piece de resistance,

      print(eval("sdata.{0}()".format(method)))

  Take a string which contains a method name, and format it into
  the string "sdata.{0}()".  So, for example if the string is "hi",
  the result of

     "sdata.{0}()".format("hi")
  is
     "sdata.hi()"

  Now, take that and evaluate it -- eval("sdata.hi()"). In other words,
  interpret the string as source code. The method sdata.hi() returns
  something, but it doesn't print the returned value. So, just as in
  your code, you must surround the call with a print.
  ____________________________________________________________________________

