2015.12.19 KJC

  It ain't tiddly but it will do. Deal.  Git's ability to diff between
  two revisions could use a LOT of work.  See "man gitrevisions". Copy
  and paste the following ghastlies, ONE at a time and study the output.
  (Installing most and "export PAGER=/usr/bin/most" in your .bashrc
  will help.)

  $ git log --reverse    # to see history in human-readable order
  $ git diff 642197bb6c4a573d7612901e2ea168c622676087..7f6e60404c1e24e08ae2815c62cbfe20f1ff92c9
  $ git diff 7f6e60404c1e24e08ae2815c62cbfe20f1ff92c9..9a824d97a81423b8e364f6bdd6e23ccb8c63e865

  ____________________________________________________________________________

2015.12.20 KJC

  In an attempt to be an enabler (but not a co-dependent), rather than
  a Frank Sinatra fix ("I did it Myyyyyyy Waaaaaayyyy") I've made what
  I consider to be minor changes to the code, that I hope will not be
  too arduous to adapt to. Now... to answer the immediate question at
  hand:  Looping through all methods of a class...

      $ ipython2

      # Disclaimer: This is a horrible and frightening way to do things

      from __future__ import print_function
      from nslcutil import *
      help(sdata)
      dir(sdata)
      attributes = dir(sdata)  # ALL attributes

      # Extract the methods, only (not all attributes)
      #
      # NOTE: "methods" and "attribute" below are just
      #       variable names and have NOTHING to do
      #       with the preceding lines
      #
      methods = [attribute for attribute in dir(sdata)
                 if not attribute.startswith("__") and
                 callable(getattr(sdata,attribute))]

      # This will print the method name, followed by
      # the output from calling said method.
      #
      for method in methods:
          print("\n{0}:".format(method))
          print(eval("sdata.{0}()".format(method)))

  Explanation: help() is your friend. Use it a LOT to get info
  about methods, objects, modules, data types, whatnot.

  dir() lists whatever's inside of the object fed to it. Sadly, these
  are strings. It list ALL attributes, including built-in stuff and
  things that are not methods.

  However, using a "list comprehension" we can filter out both built-
  in attributes, whose names all start with "__", and attributes which
  are not callable -- i.e. not methods.  But they are still,
  unfortunately strings.

  The last section above... I once again urge you to study modern
  string formatting techniques. "\n" you know. "{0}" is "put the first
  argument here". ("{1}" would be "put the second argument here".) So,
  print("\n{0}:".format(method)) is "Print a newline followed by the
  name of the method, followed by a colon".)

  And now, the piece de resistance,

      print(eval("sdata.{0}()".format(method)))

  Take a string which contains a method name, and format it into
  the string "sdata.{0}()".  So, for example if the string is "hi",
  the result of

     "sdata.{0}()".format("hi")
  is
     "sdata.hi()"

  Now, take that and evaluate it -- eval("sdata.hi()"). In other words,
  interpret the string as source code. The method sdata.hi() returns
  something, but it doesn't print the returned value. So, just as in
  your code, you must surround the call with a print.
  ____________________________________________________________________________

2015.12.22 KJC

  Based on the information provided, what does a field need to know about
  itself?  I would probably make every field an object, not a method, and
  it would look something like this tester.py
  ____________________________________________________________________________

2015.12.28 KJC

  Fixed tester.py a bit more, though Degree_Concentration remains broken
  (and commented out).  It's not just the problem that the definition
  does not exist in the PDF.  The definition provided in the code is
  is IN ERROR. YOU, not the data provider introduced a typo. While it
  they take some blame for not giving you a complete spec, you have
  compounded the problem on your own.

    #Degree_Concentration = Field("9,1,87,87,R,A,I,9")

  I believe the 9 at the beginning is bogus.  Otherwise, YOUR definition
  above states:
  
           9 = length
           1 = starting position
          87 = ending position   (in which case length should be 87)
   ****   87 = required          ****  WTF? ****
           R = type (type 1?)
           A = type (type 2?)
           I = cell
           9 = order / position

  Removing the initial "9," and inserting a second "A," gives:

           1 = length
          87 = starting position
          87 = ending position    (much better: length is 1, as stated)
           R = required
           A = type (type 1?)
    ****   A = type (type 2?)     **** Add me ***
           I = cell
           9 = order / position

  For one of the additions to tester, see the links below for an
  explanation of the difference between __str__ and __repr__ in
  Python. (Beware the word-wrapping / escaped newline in the URL
  below.)

    http://pythoncentral.io/\
    what-is-the-difference-between-__str__-and-__repr__-in-python/

    http://stackoverflow.com/questions/1436703/\
    difference-between-str-and-repr-in-python#2626364
  ____________________________________________________________________________

